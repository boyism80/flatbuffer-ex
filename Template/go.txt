{{~
func go_type_from_str(type)
    $result = ''
    case type
        when "string"
            $result = "string"
        when "byte"
            $result = "int8"
        when "ubyte"
            $result = "byte"
        when "short"
            $result = "int16"
        when "ushort"
            $result = "uint16"
        when "int"
            $result = "int32"
        when "uint"
            $result = "uint32"
        when "array"
            $result = "[]" + (field.array_element | @go_type)
        else
            $result = type
    end

    ret $result
end

func go_type(field)
    $result = @go_type_from_str(field.type)
    if field.refer_namespace
        $ns = field.refer_namespace
    else if field.is_custom_class
        $ns = field.namespace
    else
        $ns = []
    end

    $ns = ($ns | array.join '_')
    if $ns != '' && $ns != (scope.namespace | array.join '_')
        if field.is_enum
            $ns = $ns + '_' + 'raw'
        end
        $result = $ns + '.' + $result
    end

    $result = ([$result] | array.each @cs_mapped_kwd | array.join '.')

    if field.is_nullable
        $result = '*' + $result
    end

    ret $result
end

func cs_access_nullable_value(value, field)
    if field.is_custom_class
        ret value + '.Value'
    else if field.type == 'string'
        ret value
    else if field.is_nullable
        ret value + '.Value'
    else if field.is_enum
        ret '(' + (field.fixed_namespace | array.add field.type | array.each @cs_mapped_kwd | array.join '.') + ')' + value
    else if field.is_primitive
        ret value
    else
        ret value + '()'
    end
end

func cs_create_field(raw_name, field)
    $result = ''
    $flatbuffer_offset = raw_name
    if field.name
        $flatbuffer_offset = $flatbuffer_offset + '.' + (field.name | upper_camel)
    end
    $flatbuffer_value = cs_access_nullable_value($flatbuffer_offset, field)

    if field.is_bound_nullable
        $casting_type = '(' + (field.fixed_namespace | array.add (field | @go_type) | array.each @cs_mapped_kwd | array.join '.') + ')'
        $flatbuffer_value = $casting_type + $flatbuffer_value + '.Value'
    end

    if field.is_custom_class
        $value = 'new ' + field.type + '(' + $flatbuffer_value + ')'
    else if field.type == 'string'
        $value = $flatbuffer_value
    else if field.type == 'array'
        $value = 'Enumerable.Range(0, raw.' + (field.name | upper_camel) + 'Length).Select(i => raw.' + (field.name | upper_camel) + '(i)).Select(x => ' + cs_create_field('x', field.array_element) + ').ToList()'
    else if field.is_enum
        $value = $flatbuffer_value
    else
        $value = $flatbuffer_value
    end

    if field.is_nullable && field.type != 'string'
        $result = $flatbuffer_offset + ' != null ? ' + $value + ' : null'
    else
        $result = $value
    end

    ret $result
end

func cs_default_value(field)
    $result = ''
    if field.init
        $result = field.init
    else if field.is_nullable
        $result = 'null'
    else if field.is_custom_class
        $result = 'new ' + go_type(field) + '()'
    else
        case field.type
        when "string"
            $result = "string.Empty"
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "long", "ulong"
            $result = "0L"
        when "float"
            $result = "0.0f"
        when "double"
            $result = "0.0"
        when "bool"
            $result = "false"
        when "array"
            $result = "new " + go_type(field) + '()'
        end
    end

    if $result != ''
        $result = ' = ' + $result + ';'
    end

    ret $result
end

func cs_field_size(field)
    if field.is_nullable
        ret 4
    end

    case field.type
    when 'byte', 'ubyte', 'bool'
        ret 1
    when 'short', 'ushort'
        ret 2
    when 'int', 'uint', 'float'
        ret 4
    when 'long', 'ulong', 'double'
        ret 8
    end

    ret 4
end

func build_param_type(field)
    if field.is_nullable
        ret 'flatbuffers.UOffsetT'
    end

    if field.is_enum
        ret (field.namespace | array.add 'raw' | array.join '_') + '.' + field.type
    end

    if field.is_primitive == false
        ret 'flatbuffers.UOffsetT'
    end

    if field.type == 'string'
        ret 'flatbuffers.UOffsetT'
    end

    ret field | @go_type
end

func build_value(value, field)

    if field.type == 'string'
        if field.is_nullable
            ret 'fbex.BuildString(builder, ' + value + '.' + (field.name | @upper_camel) + ')'
        else
            ret 'fbex.BuildString(builder, &' + value + '.' + (field.name | @upper_camel) + ')'
        end
    end

    if field.is_nullable
        ret 'fbex.Build' + (field.type | @upper_camel) + 'Ptr(builder, ' + value + '.' + (field.name | @upper_camel) + ')'
    end

    if field.is_custom_class
        ret value + '.' + (field.name | @upper_camel) + '.Build(builder)'
    end

    if field.is_array
        if field.array_element.is_custom_class
            ret 'fbex.BuildClassArray(builder, ' + value + '.' + (field.name | @upper_camel) +')'
        else if field.array_element.type == 'string'
            ret 'fbex.BuildStringArray(builder, ' + value + '.' + (field.name | @upper_camel) +')'
        else
            ret 'Build' + (field.type | @go_type | @upper_camel) +'Array(builder, ' + value + '.' + (field.name | @upper_camel) +')'
        end
    end

    ret value + '.' + (field.name | @upper_camel)
end

func with_package(str, ns)
    if ns | array.size == 0
        ret str
    end

    ns = (ns | array.last)
    if ns == (scope.namespace | array.last)
        ret str
    end

    ret ns + '.' + str
end

func deserialize_value(value, field)
    if field.type == 'string'
        x = 'fbex.DeserializeString(' + value + '.' + (field.name | @upper_camel) + '()' + ')'
        if field.is_nullable == false
            x = '*' + x
        end
        ret x
    end

    if field.is_nullable
        ret 'fbex.Deserialize' + (field.type | @upper_camel) + 'Ptr(' + value + '.' + (field.name | @upper_camel) + '(nil))'
    end

    if field.is_custom_class
        $x = 'DeserializeRaw' + field.type + '(' + value + '.' + (field.name | @upper_camel) + '(nil)' + ')'
        ret with_package($x, field.namespace)
    end

    if field.is_array
        if field.array_element.type == 'string'
            ret 'fbex.DeserializeStringArray(value.' + (field.name | @upper_camel) + ', value.' + (field.name | @upper_camel) + 'Length())'
        else if field.array_element.is_primitive
            ret 'fbex.DeserializePrimitiveArray(value.' + (field.name | @upper_camel) + ', value.' + (field.name | @upper_camel) + 'Length())'
        else
            x = 'fbex.DeserializeClassArray(value.' + (field.name | @upper_camel) + ', value.' + (field.name | @upper_camel) + 'Length())'
            x = 'Deserialize' + field.array_element.type + 'Array(' + x + ')'
            ret with_package(x, field.array_element.namespace)
        end
    end

    ret value + '.' + (field.name | @upper_camel) + '()'
end

func build_field_param(value, field)
    if field.is_enum
        ret (field.namespace | array.add 'raw' | array.join '_') + '.' + field.type + '(' + value + ')'
    end

    ret value
end

~}}

package {{ scope.namespace | array.last }}

import (
    "{{ go_module_name }}/nullable"
    "{{ go_module_name }}/{{ scope.namespace | array.add 'raw' | array.join '/' }}"
    fbex "{{ go_module_name }}"

{{~ for include_file in include_files ~}}
    "{{ go_module_name }}/{{ include_file }}"
    {{ include_file }}_raw "{{ go_module_name }}/{{ include_file }}/raw"
{{~ end ~}}

    flatbuffers "github.com/google/flatbuffers/go"
)

{{~ for table in scope.tables ~}}
type {{ table.name }} struct {
{{~ for field in table.fields ~}}
    {{ field.name | upper_camel }} {{ field | @go_type }}
{{~ end ~}}
}

func Deserialize{{ table.name }}(bytes []byte) {{ table.name }} {
    return DeserializeRaw{{ table.name }}(raw.GetRootAs{{ table.name }}(bytes, 0))
}

func DeserializeRaw{{ table.name }}(value *raw.{{ table.name }}) {{ table.name }} {
    return {{ table.name }}{ {{ if table.fields | array.size > 0}}{{~ for field in table.fields ~}}{{ deserialize_value('value', field) }}{{~ if !for.last ~}},
{{~ end ~}}{{~ end ~}}{{~ end ~}}}
}

func Deserialize{{ table.name }}Array(values []*raw.{{ table.name }}) []{{ table.name }} {
    result := []{{ table.name }}{}
    for _, value := range values {
        result = append(result, DeserializeRaw{{ table.name }}(value))
    }
    return result
}

func NewRaw{{ table.name }}(builder *flatbuffers.Builder,
{{~ for field in table.fields ~}}
    _{{ for.index }} {{ field | @build_param_type }}{{ if !for.last }},
{{~ end ~}}{{~ end ~}}) flatbuffers.UOffsetT {
    raw.{{ table.name }}Start(builder)
{{~ for field in table.fields ~}}
    raw.{{ table.name }}Add{{ field.name | @upper_camel }}(builder, {{ build_field_param('_' + for.index, field) }})
{{~ end ~}}
    return raw.{{ table.name }}End(builder)
}

func (value {{ table.name }}) Build(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
    return NewRaw{{ table.name }}(builder,
{{~ for field in table.fields ~}}
        {{ build_value('value', field) }}{{~ if !for.last ~}},
{{ end ~}}
{{~ end ~}})
}

func (value {{ table.name }}) Serialize() []byte {
    builder := flatbuffers.NewBuilder(1024)
    offset := value.Build(builder)
    builder.Finish(offset)
    return builder.FinishedBytes()
}

{{~ end ~}}