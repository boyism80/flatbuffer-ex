{{~
func cpp_type_from_str(type)
    $result = ''
    case type
        when "string"
            $result = "std::string"
        when "byte"
            $result = "int8_t"
        when "ubyte"
            $result = "uint8_t"
        when "short"
            $result = "int16_t"
        when "ushort"
            $result = "uint16_t"
        when "uint"
            $result = "uint32_t"
        when "ulong"
            $result = "unsigned long"
        when "array"
            $result = "std::vector<" + (field.array_element | @cpp_type) + ">"
        else
            $result = type
    end

    ret $result
end

func cpp_type(field)
    $result = @cpp_type_from_str(field.type)
    if field.refer_namespace
        $result = (field.refer_namespace | array.add $result | array.join '::')
    else if field.is_custom_class
        $result = (field.scope.namespace | array.add $result | array.join '::')
    end

    if field.is_nullable
        $result = 'std::optional<' + $result + '>'
    end

    ret $result
end

func cpp_field_to_ctr_param(field)
    $result = field | @cpp_type

    if field.type == 'string'
        $result = 'const ' + $result + '&'
    else if field.is_nullable
        $result = 'const ' + $result + '&'
    end

    ret $result
end

func cpp_field_to_build_param(field)
    $result = ''
    if field.type == 'string'
        if field.is_nullable
            $result = 'builder.CreateString(this->' + field.name + '.value())'
        else
            $result = 'builder.CreateString(this->' + field.name + ')'
        end
    else if field.is_custom_class
        $result = 'this->' + field.name + '.Build(builder)'
    else if field.type == 'array'
        $result = 'this->Create' + (field.name | string.capitalize) + '(builder)'
    else if field.is_enum
        $result = '(' + (field.refer_namespace | array.add 'raw' | array.add field.type | array.join '::') + ')' + 'this->' + field.name
    else
        $result = 'this->' + field.name
    end

    if field.is_nullable
        if field.type == 'string'
            $result = 'this->' + field.name + '.has_value() ? nullable::Createnullable_string(builder, ' + $result + ') : flatbuffers::Offset<nullable::nullable_string>{ 0 }'
        else
            $result = 'this->' + field.name + '.has_value() ? ' + $result + '.value() : 0'
        end
    end

    ret $result
end

func cpp_raw_to_field(field)
    $result = ''
    if field.type == 'string'
        $result = 'raw.' + field.name + '()'
    else if field.is_custom_class
        $result = '*raw.' + field.name + '()'
    else if field.is_enum
        $result = '(' + (field.refer_namespace | array.add field.type | array.join '::') + ')' + 'raw.' + field.name + '()'
    else
        $result = 'raw.' + field.name + '()'
    end

    if field.is_nullable
        $result = $result + '->value()'
    end

    if field.type == 'string'
        $result = $result + '->c_str()'
    end

    if field.is_nullable
        $result = 'raw.' + field.name + '() != nullptr ? std::optional<' + (field.type | @cpp_type_from_str) + '>(' + $result + ') : std::optional<' + (field.type | @cpp_type_from_str) + '>()'
    end
    ret $result
end

func is_array_type(field)
    ret field.type == 'array'
end

func is_not_array_type(field)
    ret field.type != 'array'
end

func cpp_default_value(field)
    $result = ''
    if field.is_nullable
        $result = 'std::nullopt'
    else
        case field.type
        when "string"
            $result = "\"\""
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "bool"
            $result = "false"
        end
    end

    if $result != ''
        $result = ' = ' + $result
    end

    ret $result
end
~}}
#ifndef __FLATBUFFER_PROTOCOL_H__
#define __FLATBUFFER_PROTOCOL_H__

#include <string>
#include <optional>
{{~ for scope in context.scopes ~}}
{{~ for enum in scope.enums ~}}
#include <{{ include_path }}/{{ scope.namespace | array.join '.' | string.downcase }}.{{ enum.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ for table in scope.tables ~}}
#include <{{ include_path }}/{{ scope.namespace | array.join '.' | string.downcase }}.{{ table.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}
{{~ end ~}}
{{~ for enum in scope.enums ~}}
enum class {{ enum.name }} : {{ enum.type | @cpp_type_from_str }}
{
{{~ for value in enum.values ~}}
    {{ value }} = {{ enum.scope.namespace | array.add 'raw' | array.add enum.name | array.add enum.name + '_' + value | array.join '::' }},
{{~ end ~}}
};
{{~ end ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}

enum class FlatBufferProtocolType
{
{{~ for table in scope.tables ~}}
    {{ table.name }},
{{~ end ~}}
};

{{~ for table in scope.tables ~}}
class {{ table.name }}
{
public:
    static inline {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.join '::' }} FlatBufferProtocolType = {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.add table.name | array.join '::' }};

{{~ if (table.fields | array.size) > 0 ~}}
public:
{{~ for field in table.fields ~}}
    {{ field | @cpp_type }} {{ field.name }}{{ field | @cpp_default_value }};
{{~ end ~}}
{{~ end ~}}

public:
    {{ table.name }}() = default;

    {{ table.name }}(const {{ table.name }}& x)
{{~ if (table.fields | array.size) > 0 ~}}
        : {{ for field in table.fields }}{{ field.name }}(x.{{ field.name }}){{ if !for.last }}, {{end }}{{ end }}
{{~ end ~}}
    { }

{{~ if (table.fields | array.size) > 0 ~}}
    {{ table.name }}({{ for field in table.fields }}{{ field | @cpp_field_to_ctr_param }} {{ field.name }}{{ if !for.last }}, {{end }}{{ end }})
        : {{ for field in table.fields }}{{ field.name }}({{ field.name }}){{ if !for.last }}, {{ end }}{{ end }}
    { }
{{~ end ~}}

    {{ table.name }}(const {{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}& raw)
{{~ if (table.fields | array.filter @is_not_array_type | array.size) > 0~}}
        : {{ for field in table.fields | array.filter @is_not_array_type }}{{ field.name }}({{ field | @cpp_raw_to_field }}){{ if !for.last }}, {{ end }}{{ end }}
{{~ end ~}}
    {
{{~ for field in table.fields | array.filter @is_array_type ~}}
        for (int i = 0; i < raw.{{ field.name }}()->size(); i++)
        {
{{~ if field.array_element.is_nullable ~}}
            this->{{ field.name }}.push_back(raw.{{ field.name }}()->Get(i) != nullptr ? std::optional<{{ field.array_element.type | @cpp_type_from_str }}>({{~ if field.array_element.is_enum ~}}({{ field.array_element.type }}){{~ end ~}}raw.{{ field.name }}()->Get(i)->value()) : std::optional<{{ field.array_element.type | @cpp_type_from_str }}>());
{{~ else ~}}
            this->{{ field.name }}.push_back(*raw.{{ field.name }}()->Get(i));
{{~ end ~}}
        }
{{~ end ~}}
    }

{{~ if (table.fields | array.filter @is_array_type | array.size) > 0 ~}}
private:
{{~ for field in table.fields | array.filter @is_array_type ~}}
    auto Create{{ field.name | string.capitalize }}(flatbuffers::FlatBufferBuilder& builder) const
    {
{{~ if field.array_element.is_nullable ~}}
        auto result = std::vector<flatbuffers::Offset<nullable::nullable_{{ field.array_element.fixed_namespace | array.add field.array_element.type | array.join '_' | string.downcase }}>>();
        for(auto& x : this->{{ field.name }})
        {
            auto nullable_builder = nullable::nullable_{{ field.array_element.fixed_namespace | array.add field.array_element.type | array.join '_' | string.downcase }}Builder(builder);
            if(x.has_value())
                nullable_builder.add_value({{~ if field.array_element.is_enum ~}}({{ field.array_element.fixed_namespace | array.add 'raw' | array.add field.array_element.type | array.join '::' }}){{~ end ~}}x.value());
            result.push_back(nullable_builder.Finish());
        }
{{~ else ~}}
        auto result = std::vector<flatbuffers::Offset<{{ (field.array_element.namespace) | array.add 'raw' | array.add field.array_element.type | array.join '::' }}>>();
        for(auto& x : this->{{ field.name }})
        {
            result.push_back(x.Build(builder));
        }
{{~ end ~}}

        return builder.CreateVector(result);
    }
{{~ end ~}}
{{~ end ~}}

public:
    auto Build(flatbuffers::FlatBufferBuilder& builder) const
    {
        return {{ scope.namespace | array.add 'raw' | array.add 'Create' + table.name | array.join '::' }}(builder{{ if (table.fields | array.size) > 0 }},
{{~ for field in table.fields ~}}
            {{ field | @cpp_field_to_build_param }}{{ if !for.last }},
{{ end }}{{~ end ~}}{{ end }});
    }

    std::vector<uint8_t> Serialize() const
    {
        auto builder = flatbuffers::FlatBufferBuilder();
        builder.Finish(this->Build(builder));
        auto size = builder.GetSize();
        auto result = std::vector<uint8_t>(size);
        std::memcpy(result.data(), builder.GetBufferPointer(), size);
        return result;
    }

    static {{ table.name }} Deserialize(const uint8_t* bytes)
    {
        auto raw = {{ scope.namespace | array.add 'raw' | array.add 'Get' + table.name | array.join '::' }}(bytes);
        return {{ table.name }}(*raw);
    }
};
{{~ end ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}

#endif