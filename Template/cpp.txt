{{~
func remove_nullable(field)
    $clone = field | clone_field
    $clone.is_nullable = false
    ret $clone
end

func to_field(type)
    ret {
        context: null,
        scope: null,
        table: null,
        name: null,
        type: type,
        refer_namespace: null,
        array_element: null,
        is_nullable: false
    }
end

func cpp_type(field)
    $result = ''
    case field.type
        when "string"
            $result = "std::string"
        when "byte"
            $result = "int8_t"
        when "ubyte"
            $result = "uint8_t"
        when "short"
            $result = "int16_t"
        when "ushort"
            $result = "uint16_t"
        when "uint"
            $result = "uint32_t"
        when "ulong"
            $result = "unsigned long"
        when "array"
            $result = "std::vector<" + (field.array_element | @cpp_type) + ">"
        when "bool"
            $result = "bool"
        else
            $result = field.type
    end

    if field.refer_namespace
        $result = (field.refer_namespace | array.add $result | array.join '::')
    else if field.is_custom_class
        $result = (field.scope.namespace | array.add $result | array.join '::')
    end

    if field.is_nullable
        $result = 'std::optional<' + $result + '>'
    end

    ret $result
end

func cpp_decorate_const_ref(field)
    $result = field | @cpp_type

    if field.is_nullable || field.type == 'string' || field.is_custom_class
        $result = 'const ' + $result + '&'
    end

    ret $result
end

func cpp_offset_type(field)
    $result = ''
    if field.type == 'string'
        $result = 'flatbuffers::flatbuffers::String'
    else if field.is_bound_nullable
        $result = 'nullable::' + (['nullable'] | array.concat field.fixed_namespace | array.add (field.type | string.downcase) | array.join '_')
    else if field.is_custom_class
        $result = field.fixed_namespace | array.add 'raw' | array.add field.type | array.join '::'
    else
        $result = field | @cpp_type
    end

    if !field.is_primitive || field.type == 'string' || field.is_nullable
        ret 'flatbuffers::Offset<' + $result + '>'
    else
        ret $result
    end
end

func cpp_create_field(raw_name, field)
    $result = ''

    $flatbuffer_offset = raw_name + '.' + field.name + '()'
    $cpp_value = $flatbuffer_offset
    if field.is_bound_nullable
        $cpp_value = $flatbuffer_offset + '->value()'
    end

    if field.type == 'string'
        $cpp_value = $cpp_value + '->c_str()'
        $cpp_value = 'flatbuffers::option::decode(' + $cpp_value + ')'
    else if field.is_enum
        $cpp_value = '(' + (field.fixed_namespace | array.add field.type | array.join '::') + ')' + $cpp_value
    else if field.is_custom_class
        $cpp_value = '*' + $flatbuffer_offset
    else if field.is_array
        if field.array_element.is_primitive
            $cpp_value = 'unpack<' + cpp_type(field.array_element) + '>(raw.' + field.name + '())'
        else
            $cpp_value = 'unpack<' + cpp_type(field.array_element) + '>(raw.' + field.name + '())'
        end
    end

    if field.is_nullable
        $result = $flatbuffer_offset + ' != nullptr ? ' + $cpp_value + ' : ' + cpp_type(field) + '()'
    else
        $result = $cpp_value
    end

    ret $result
end

func cpp_access_nullable_value(value, field)
    if !field.is_nullable
        ret value
    else if field.string || field.is_custom_class
        ret '*' + value
    else if field.is_primitive
        ret value + '->value()'
    else
        ret 'unknown'
    end
end

func cpp_default_value(field)
    $result = ''
    if field.init
        $result = field.init
    else if field.is_nullable
        $result = 'std::nullopt'
    else
        case field.type
        when "string"
            $result = ''
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "long", "ulong"
            $result = "0L"
        when "float"
            $result = "0.0f"
        when "double"
            $result = "0.0"
        when "bool"
            $result = "false"
        when "array"
            $result = '{}'
        end
    end

    if $result != ''
        $result = ' = ' + $result
    end

    ret $result
end
~}}
// clang-format off

#ifndef __FLATBUFFER_PROTOCOL_H__
#define __FLATBUFFER_PROTOCOL_H__

#include <string>
#include <optional>
{{~ for scope in context.scopes ~}}
{{~ for enum in scope.enums ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ enum.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ for table in scope.tables ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ table.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
namespace {{ scope.namespace | array.join '::' }}
{
{{~ for table in scope.tables ~}}
    class {{ table.name }};
{{~ end ~}}
{{~ for enum in scope.enums ~}}
    enum class {{ enum.name }} : {{ { type: enum.type } | @cpp_type }};
{{~ end ~}}
} // end of namespace {{ scope.namespace | array.join '::' }}
{{~ end ~}}


namespace flatbuffers {

class option
{
public:
    using encoding_func_type = std::function<std::string(const std::string&)>;

private:
    encoding_func_type encoding_func;
    encoding_func_type decoding_func;

private:
    option() = default;

public:
    ~option() = default;

private:
    static option& get()
    {
        static std::once_flag flag;
        static std::unique_ptr<option> ist;

        std::call_once(flag, [] 
        {
            ist = std::unique_ptr<option>(new option());
        });
        return *ist;
    }

public:
    static void encoding(const encoding_func_type& fn)
    {
        auto& ist = get();
        ist.encoding_func = fn;
    }

public:
    static void decoding(const encoding_func_type& fn)
    {
        auto& ist = get();
        ist.decoding_func = fn;
    }

public:
    static std::string encode(const std::string& value)
    {
        auto& ist = get();
        if (ist.encoding_func)
        {
            return ist.encoding_func(value);
        }
        else
        {
            return value;
        }
    }

public:
    static std::string decode(const std::string& value)
    {
        auto& ist = get();
        if (ist.decoding_func)
        {
            return ist.decoding_func(value);
        }
        else
        {
            return value;
        }
    }
};

template<typename>   constexpr bool is_optional_impl = false;
template<typename T> constexpr bool is_optional_impl<std::optional<T>> = true;
template<>           constexpr bool is_optional_impl<std::nullopt_t> = true;
template<typename T> constexpr bool is_optional = is_optional_impl<std::decay_t<T>>;

template<typename>   constexpr bool is_vector_impl = false;
template<typename T> constexpr bool is_vector_impl<std::vector<T>> = true;
template<typename T> constexpr bool is_vector = is_vector_impl<std::decay_t<T>>;


template <typename T> struct FlatBufferOffset { typedef T type; };
template <> struct FlatBufferOffset<std::string> { typedef flatbuffers::Offset<flatbuffers::String> type; };
{{~ for field in context.nullable_fields ~}}
{{~ if field.is_primitive ~}}
template <> struct FlatBufferOffset<{{ field | @cpp_type }}> { typedef flatbuffers::Offset< nullable::nullable_{{ field.type }}> type; };
{{~ end ~}}
{{~ end ~}}
{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <> struct FlatBufferOffset<{{ table.scope.namespace | array.add table.name | array.join '::' }}> { typedef flatbuffers::Offset<{{ table.scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> type; };
{{~ end ~}}
{{~ end ~}}
{{~ for scope in context.scopes ~}}
{{~ for enum in scope.enums ~}}
template <> struct FlatBufferOffset<{{ enum.scope.namespace | array.add enum.name | array.join '::' }}> { typedef {{ enum.scope.namespace | array.add 'raw' | array.add enum.name | array.join '::' }} type; };
{{~ end ~}}
{{~ end ~}}
template <typename T> struct FlatBufferOffset<std::optional<T>> { typedef typename FlatBufferOffset<T>::type type; };
template <typename T> struct FlatBufferOffset<std::vector<T>> { typedef flatbuffers::Offset<flatbuffers::Vector<typename FlatBufferOffset<T>::type>> type; };

template <typename T> inline static
typename FlatBufferOffset<T>::type build(FlatBufferBuilder& builder, const T& value);
template <>
flatbuffers::Offset<flatbuffers::String> build<std::string>(FlatBufferBuilder& builder, const std::string& value);
{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <>
flatbuffers::Offset<{{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> build<{{ scope.namespace | array.add table.name | array.join '::' }}>(FlatBufferBuilder& builder, const {{ scope.namespace | array.add table.name | array.join '::' }}& value);
{{~ end ~}}
{{~ end ~}}

template <typename T> inline static
std::vector<T> unpack(const flatbuffers::Vector<typename FlatBufferOffset<T>::type> *value);

} // end of namespace flatbuffers

{{~ for scope in context.scopes ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
namespace {{ scope.namespace | array.join '::' }} {

{{~ end ~}}
{{~ for enum in scope.enums ~}}
enum class {{ enum.name }} : {{ to_field(enum.type) | @cpp_type }}
{
{{~ for value in enum.values ~}}
    {{ value }} = {{ enum.scope.namespace | array.add 'raw' | array.add enum.name | array.add enum.name + '_' + value | array.join '::' }},
{{~ end ~}}
};
{{~ end ~}}
{{~ if (scope.enums | array.size) > 0 ~}}

} // end of namespace {{ scope.namespace | array.join '::' }}
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
namespace {{ scope.namespace | array.join '::' }} {

enum class FlatBufferProtocolType
{
{{~ for table in scope.tables ~}}
    {{ table.name }},
{{~ end ~}}
};

{{~ for table in scope.tables ~}}
class {{ table.name }}
{
public:
    static inline {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.join '::' }} FlatBufferProtocolType = {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.add table.name | array.join '::' }};

{{~ if (table.fields | array.size) > 0 ~}}
public:
{{~ for field in table.fields ~}}
    {{ field | @cpp_type }} {{ field.name }}{{ field | @cpp_default_value }};
{{~ end ~}}
{{~ end ~}}

public:
    {{ table.name }}() = default;

    {{ table.name }}(const {{ table.name }}& x)
{{~ if (table.fields | array.size) > 0 ~}}
        : {{ for field in table.fields }}{{ field.name }}(x.{{ field.name }}){{ if !for.last }}, {{end }}{{ end }}
{{~ end ~}}
    { }

{{~ if (table.fields | array.size) > 0 ~}}
    {{ table.name }}({{ for field in table.fields }}{{ field | @cpp_decorate_const_ref }} {{ field.name }}{{ if !for.last }}, {{end }}{{ end }})
        : {{ for field in table.fields }}{{ field.name }}({{ field.name }}){{ if !for.last }}, {{ end }}{{ end }}
    { }
{{~ end ~}}

    {{ table.name }}(const {{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}& raw)
{{~ if (table.fields | array.size) > 0~}}
        : {{ for field in table.fields }}{{ field.name }}({{ cpp_create_field('raw', field) }}){{ if !for.last }}, {{ end }}{{ end }}
{{~ end ~}}
    { }

public:
    std::vector<uint8_t> Serialize() const
    {
        auto builder = flatbuffers::FlatBufferBuilder();
        builder.Finish(build<{{ table.scope.namespace | array.add table.name | array.join '::' }}>(builder, *this));
        auto buffer = std::vector<uint8_t>(builder.GetSize());
        std::memcpy(buffer.data(), builder.GetBufferPointer(), builder.GetSize());
        return buffer;
    }

    static {{ table.name }} Deserialize(const uint8_t* bytes)
    {
        auto raw = {{ scope.namespace | array.add 'raw' | array.add 'Get' + table.name | array.join '::' }}(bytes);
        return {{ table.name }}(*raw);
    }
};
{{~ end ~}}

} // end of namespace {{ scope.namespace | array.join '::' }}

{{~ end ~}}

namespace flatbuffers {

template <typename T> inline static
typename FlatBufferOffset<T>::type build(FlatBufferBuilder& builder, const T& value)
{
    if constexpr (is_optional<T>)
    {
        if (!value.has_value())
            return 0;
            
{{~ for nullable_field in context.nullable_fields ~}}
{{~ if nullable_field.is_primitive ~}}
        if constexpr (std::is_same_v<T, {{ nullable_field | @cpp_type }}>)
        {
            return nullable::Createnullable_{{ nullable_field.type }}(builder, value.value());
        }

{{~ end ~}}
{{~ end ~}}
        return build<typename T::value_type>(builder, value.value());
    }
    else if constexpr (is_vector<T>)
    {
        if constexpr (std::is_fundamental_v<typename T::value_type>)
        {
            return builder.CreateVector(value);
        }
        else
        {
            auto buffer = std::vector<typename FlatBufferOffset<typename T::value_type>::type>();
            for (auto& x : value)
            {
                buffer.push_back(build<typename T::value_type>(builder, x));
            }
            return builder.CreateVector(buffer);
        }
    }
    else if constexpr (std::is_enum_v<T>)
    {
        return static_cast<typename FlatBufferOffset<T>::type>(value);
    }
    else
    {
        return value;
    }
}

template <> 
flatbuffers::Offset<flatbuffers::String> build<std::string>(FlatBufferBuilder& builder, const std::string& value)
{
    return builder.CreateString(flatbuffers::option::encode(value));
}

{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <>
flatbuffers::Offset<{{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> build<{{ scope.namespace | array.add table.name | array.join '::' }}>(FlatBufferBuilder& builder, const {{ scope.namespace | array.add table.name | array.join '::' }}& value)
{
    return {{ scope.namespace | array.add 'raw' | array.add 'Create' + table.name | array.join '::' }}(builder{{ if (table.fields | array.size) > 0 }},
{{~ for field in table.fields ~}}
            flatbuffers::build<{{ field | @cpp_type }}>(builder, value.{{ field.name }}){{ if !for.last }},
{{ end }}{{~ end ~}}{{ end }});
}
{{~ end ~}}
{{~ end ~}}

template <typename T> inline static
std::vector<T> unpack(const flatbuffers::Vector<typename FlatBufferOffset<T>::type> *value)
{
    auto result = std::vector<T>();
    for (int i = 0; i < value->size(); i++)
    {
        if constexpr (is_optional<T>)
        {
            if (value->Get(i) == nullptr)
            {
                result.push_back(std::nullopt);
            }
            else if constexpr (std::is_fundamental_v<typename T::value_type>)
            {
                result.push_back(value->Get(i)->value());
            }
            else
            {
                result.push_back(*value->Get(i));
            }
        }
        else
        {
            if constexpr (std::is_fundamental_v<T>)
            {
                result.push_back(value->Get(i));
            }
            else if constexpr (std::is_same_v<T, std::string>)
            {
                result.push_back(flatbuffers::option::decode(value->Get(i)->c_str()));
            }
            else
            {
                if (value->Get(i) == nullptr)
                    continue;
                    
                result.push_back(*value->Get(i));
            }
        }
    }
    return result;
}

}

#endif