{{~
func remove_nullable(field)
    $clone = field | clone_field
    $clone.is_nullable = false
    ret $clone
end

func to_field(type)
    ret {
        context: null,
        scope: null,
        table: null,
        name: null,
        type: type,
        refer_namespace: null,
        array_element: null,
        is_nullable: false
    }
end

func cpp_type(field)
    $result = ''
    case field.type
        when "string"
            $result = "std::string"
        when "byte"
            $result = "int8_t"
        when "ubyte"
            $result = "uint8_t"
        when "short"
            $result = "int16_t"
        when "ushort"
            $result = "uint16_t"
        when "uint"
            $result = "uint32_t"
        when "ulong"
            $result = "unsigned long"
        when "array"
            $result = "std::vector<" + (field.array_element | @cpp_type) + ">"
        when "bool"
            $result = "bool"
        else
            $result = field.type
    end

    if field.refer_namespace
        $result = (field.refer_namespace | array.add $result | array.join '::')
    else if field.is_custom_class
        $result = (field.scope.namespace | array.add $result | array.join '::')
    end

    if field.is_nullable
        $result = 'std::optional<' + $result + '>'
    end

    ret $result
end

func cpp_decorate_const_ref(field)
    $result = field | @cpp_type

    if field.type == 'string'
        $result = 'const ' + $result + '&'
    else if field.is_nullable
        $result = 'const ' + $result + '&'
    end

    ret $result
end

func cpp_offset_type(field)
    $result = ''
    if field.type == 'string'
        $result = 'flatbuffers::String'
    else if field.is_nullable && field.type != 'string' && !field.is_custom_class
        $result = 'nullable::nullable_' + field.type
    else if field.is_custom_class
        $result = field.fixed_namespace | array.add 'raw' | array.add field.type | array.join '::'
    else
        $result = field | @cpp_type
    end

    if !field.is_primitive || field.type == 'string' || field.is_nullable
        ret 'flatbuffers::Offset<' + $result + '>'
    else
        ret $result
    end
end

func cpp_create_offset(field)
    $value = field.name
    if field.is_nullable
        $value = $value + '.value()'
    end

    $result = ''
    if field.type == 'string'
        $result = 'builder.CreateString(' + $value + ')'
    else if field.is_custom_class
        $result = $value + '.Build(builder)'
    else if field.is_enum
        $result = '(' + (field.fixed_namespace | array.add 'raw' | array.add field.type | array.join '::') + ')' + $value
    else if field.type == 'array'
        $result = 'this->Create' + (field.name | string.capitalize) + '(builder)'
    else
        $result = $value
    end

    if field.is_nullable
        $result = field.name + '.has_value() ? ' + $result + ': 0'
    end

    ret $result
end

func cpp_create_field(raw_name, field)
    $result = ''

    $flatbuffer_value = raw_name + '.' + field.name + '()'
    if field.type == 'array'
        $flatbuffer_value = $flatbuffer_value + '->Get(i)'
        field = field.array_element
    end

    $cpp_value = $flatbuffer_value
    if field.is_nullable && field.is_primitive && field.type != 'string'
        $cpp_value = $flatbuffer_value + '->value()'
    end

    if field.type == 'string'
        $cpp_value = $cpp_value + '->c_str()'
    else if field.is_enum
        $cpp_value = '(' + (field.fixed_reference | array.add field.type | array.join '::') + ')' + $cpp_value
    else if field.is_custom_class
        $cpp_value = '*' + $flatbuffer_value
    end

    if field.is_nullable
        $result = $flatbuffer_value + ' != nullptr ? ' + $cpp_value + ' : ' + cpp_type(field) + '()'
    else
        $result = $cpp_value
    end

    ret $result
end

func cpp_access_nullable_value(value, field)
    if !field.is_nullable
        ret value
    else if field.string || field.is_custom_class
        ret '*' + value
    else if field.is_primitive
        ret value + '->value()'
    else
        ret 'unknown'
    end
end

func is_array_type(field)
    ret field.type == 'array'
end

func is_not_array_type(field)
    ret field.type != 'array'
end

func cpp_default_value(field)
    $result = ''
    if field.is_nullable
        $result = 'std::nullopt'
    else
        case field.type
        when "string"
            $result = "\"\""
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "bool"
            $result = "false"
        end
    end

    if $result != ''
        $result = ' = ' + $result
    end

    ret $result
end
~}}
#ifndef __FLATBUFFER_PROTOCOL_H__
#define __FLATBUFFER_PROTOCOL_H__

#include <string>
#include <optional>
{{~ for scope in context.scopes ~}}
{{~ for enum in scope.enums ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ enum.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ for table in scope.tables ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ table.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}
{{~ end ~}}
{{~ for enum in scope.enums ~}}
enum class {{ enum.name }} : {{ to_field(enum.type) | @cpp_type }}
{
{{~ for value in enum.values ~}}
    {{ value }} = {{ enum.scope.namespace | array.add 'raw' | array.add enum.name | array.add enum.name + '_' + value | array.join '::' }},
{{~ end ~}}
};
{{~ end ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}

enum class FlatBufferProtocolType
{
{{~ for table in scope.tables ~}}
    {{ table.name }},
{{~ end ~}}
};

{{~ for table in scope.tables ~}}
class {{ table.name }}
{
public:
    static inline {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.join '::' }} FlatBufferProtocolType = {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.add table.name | array.join '::' }};

{{~ if (table.fields | array.size) > 0 ~}}
public:
{{~ for field in table.fields ~}}
    {{ field | @cpp_type }} {{ field.name }}{{ field | @cpp_default_value }};
{{~ end ~}}
{{~ end ~}}

public:
    {{ table.name }}() = default;

    {{ table.name }}(const {{ table.name }}& x)
{{~ if (table.fields | array.size) > 0 ~}}
        : {{ for field in table.fields }}{{ field.name }}(x.{{ field.name }}){{ if !for.last }}, {{end }}{{ end }}
{{~ end ~}}
    { }

{{~ if (table.fields | array.size) > 0 ~}}
    {{ table.name }}({{ for field in table.fields }}{{ field | @cpp_decorate_const_ref }} {{ field.name }}{{ if !for.last }}, {{end }}{{ end }})
        : {{ for field in table.fields }}{{ field.name }}({{ field.name }}){{ if !for.last }}, {{ end }}{{ end }}
    { }
{{~ end ~}}

    {{ table.name }}(const {{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}& raw)
{{~ if (table.fields | array.filter @is_not_array_type | array.size) > 0~}}
        : {{ for field in table.fields | array.filter @is_not_array_type }}{{ field.name }}({{ cpp_create_field('raw', field) }}){{ if !for.last }}, {{ end }}{{ end }}
{{~ end ~}}
    {
{{~ for field in table.fields | array.filter @is_array_type ~}}
        for (int i = 0; i < raw.{{ field.name }}()->size(); i++)
        {
            this->{{ field.name }}.push_back({{ cpp_create_field('raw', field) }});
        }
{{~ end ~}}
    }

{{~ if (table.fields | array.filter @is_array_type | array.size) > 0 ~}}
private:
{{~ for field in table.fields | array.filter @is_array_type ~}}
    auto Create{{ field.name | string.capitalize }}(flatbuffers::FlatBufferBuilder& builder) const
    {
        auto result = std::vector<{{ field.array_element | @cpp_offset_type }}>();
        for (auto& x : this->{{ field.name }})
        {
{{~
clone = field.array_element | clone_field
clone.name = 'x'
~}}
            result.push_back({{ clone | @cpp_create_offset }});
        }
        return builder.CreateVector(result);
    }
{{~ end ~}}
{{~ end ~}}

public:
    auto Build(flatbuffers::FlatBufferBuilder& builder) const
    {
        return {{ scope.namespace | array.add 'raw' | array.add 'Create' + table.name | array.join '::' }}(builder{{ if (table.fields | array.size) > 0 }},
{{~ for field in table.fields ~}}
            {{ field | @cpp_create_offset }}{{ if !for.last }},
{{ end }}{{~ end ~}}{{ end }});
    }

    std::vector<uint8_t> Serialize() const
    {
        auto builder = flatbuffers::FlatBufferBuilder();
        builder.Finish(this->Build(builder));
        auto size = builder.GetSize();
        auto result = std::vector<uint8_t>(size);
        std::memcpy(result.data(), builder.GetBufferPointer(), size);
        return result;
    }

    static {{ table.name }} Deserialize(const uint8_t* bytes)
    {
        auto raw = {{ scope.namespace | array.add 'raw' | array.add 'Get' + table.name | array.join '::' }}(bytes);
        return {{ table.name }}(*raw);
    }
};
{{~ end ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}

#endif