{{~
func remove_nullable(field)
    $clone = field | clone_field
    $clone.is_nullable = false
    ret $clone
end

func to_field(type)
    ret {
        context: null,
        scope: null,
        table: null,
        name: null,
        type: type,
        refer_namespace: null,
        array_element: null,
        is_nullable: false
    }
end

func cpp_type(field)
    $result = ''
    case field.type
        when "string"
            $result = "std::string"
        when "byte"
            $result = "int8_t"
        when "ubyte"
            $result = "uint8_t"
        when "short"
            $result = "int16_t"
        when "ushort"
            $result = "uint16_t"
        when "uint"
            $result = "uint32_t"
        when "ulong"
            $result = "unsigned long"
        when "array"
            $result = "std::vector<" + (field.array_element | @cpp_type) + ">"
        when "bool"
            $result = "bool"
        else
            $result = field.type
    end

    if field.refer_namespace
        $result = (field.refer_namespace | array.add $result | array.join '::')
    else if field.is_custom_class
        $result = (field.scope.namespace | array.add $result | array.join '::')
    end

    if field.is_nullable
        $result = 'std::optional<' + $result + '>'
    end

    ret $result
end

func cpp_decorate_const_ref(field)
    $result = field | @cpp_type

    if field.is_nullable || field.type == 'string' || field.is_custom_class
        $result = 'const ' + $result + '&'
    end

    ret $result
end

func cpp_offset_type(field)
    $result = ''
    if field.type == 'string'
        $result = 'flatbuffers::String'
    else if field.is_bound_nullable
        $result = 'nullable::' + (['nullable'] | array.concat field.fixed_namespace | array.add (field.type | string.downcase) | array.join '_')
    else if field.is_custom_class
        $result = field.fixed_namespace | array.add 'raw' | array.add field.type | array.join '::'
    else
        $result = field | @cpp_type
    end

    if !field.is_primitive || field.type == 'string' || field.is_nullable
        ret 'flatbuffers::Offset<' + $result + '>'
    else
        ret $result
    end
end

func cpp_create_offset(field, field_name=null)
    if field_name == null
        field_name = field.name
    end
    $value = field_name
    $result = ''
    if field.is_enum
        $result = '(' + (field.fixed_namespace | array.add 'raw' | array.add field.type | array.join '::') + ')' + $value
    else
        $result = 'flatbuffers::build<' + cpp_type(field) + '>(builder, ' + $value + ')'
    end

    ret $result
end

func cpp_create_field(raw_name, field)
    $result = ''

    $flatbuffer_offset = raw_name + '.' + field.name + '()'
    $cpp_value = $flatbuffer_offset
    if field.is_bound_nullable
        $cpp_value = $flatbuffer_offset + '->value()'
    end

    if field.type == 'string'
        $cpp_value = $cpp_value + '->c_str()'
    else if field.is_enum
        $cpp_value = '(' + (field.fixed_namespace | array.add field.type | array.join '::') + ')' + $cpp_value
    else if field.is_custom_class
        $cpp_value = '*' + $flatbuffer_offset
    else if field.is_array
        if field.array_element.is_primitive
            $cpp_value = 'unpack<' + cpp_type(field.array_element) + '>(raw.' + field.name + '())'
        else
            $cpp_value = 'unpack<' + cpp_type(field.array_element) + '>(raw.' + field.name + '())'
        end
    end

    if field.is_nullable
        $result = $flatbuffer_offset + ' != nullptr ? ' + $cpp_value + ' : ' + cpp_type(field) + '()'
    else
        $result = $cpp_value
    end

    ret $result
end

func cpp_access_nullable_value(value, field)
    if !field.is_nullable
        ret value
    else if field.string || field.is_custom_class
        ret '*' + value
    else if field.is_primitive
        ret value + '->value()'
    else
        ret 'unknown'
    end
end

func cpp_default_value(field)
    $result = ''
    if field.is_nullable
        $result = 'std::nullopt'
    else
        case field.type
        when "string"
            $result = "\"\""
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "bool"
            $result = "false"
        when "array"
            $result = "{}"
        end
    end

    if $result != ''
        $result = ' = ' + $result
    end

    ret $result
end
~}}
#ifndef __FLATBUFFER_PROTOCOL_H__
#define __FLATBUFFER_PROTOCOL_H__

#include <string>
#include <optional>
{{~ for scope in context.scopes ~}}
{{~ for enum in scope.enums ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ enum.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ for table in scope.tables ~}}
#include <{{ if include_path != '' }}{{ include_path }}/{{ end }}{{ scope.namespace | array.join '.' | string.downcase }}.{{ table.name | string.downcase }}_generated.h>
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
namespace {{ scope.namespace | array.join '::' }}
{
{{~ for table in scope.tables ~}}
    class {{ table.name }};
{{~ end ~}}
}
{{~ end ~}}


namespace flatbuffers {
template<typename>   constexpr bool is_optional_impl = false;
template<typename T> constexpr bool is_optional_impl<std::optional<T>> = true;
template<> constexpr bool is_optional_impl<std::nullopt_t> = true;
template<typename T>  constexpr bool is_optional = is_optional_impl<std::decay_t<T>>;

template<typename>   constexpr bool is_vector_impl = false;
template<typename T> constexpr bool is_vector_impl<std::vector<T>> = true;
template<typename T>  constexpr bool is_vector = is_vector_impl<std::decay_t<T>>;


template <typename T> struct FlatBufferOffset { typedef T type; };
template <> struct FlatBufferOffset<std::string> { typedef Offset<String> type; };
{{~ for field in context.nullable_fields ~}}
{{~ if field.is_primitive ~}}
template <> struct FlatBufferOffset<{{ field | @cpp_type }}> { typedef Offset< nullable::nullable_{{ field.type }}> type; };
{{~ end ~}}
{{~ end ~}}
{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <> struct FlatBufferOffset<{{ table.scope.namespace | array.add table.name | array.join '::' }}> { typedef Offset<{{ table.scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> type; };
{{~ end ~}}
{{~ end ~}}
{{~ for enum in context.enums ~}}
template <> struct FlatBufferOffset<{{ enum.namespace | array.add enum.name | array.join '::' }}> { typedef {{ enum.namespace | array.add 'raw' | array.add enum.name | array.join '::' }} type; };
{{~ end ~}}
template <typename T> struct FlatBufferOffset<std::optional<T>> { typedef FlatBufferOffset<typename T>::type type; };
template <typename T> struct FlatBufferOffset<std::vector<T>> { typedef flatbuffers::Offset<flatbuffers::Vector<typename FlatBufferOffset<T>::type>> type; };

template <typename T> inline static
typename FlatBufferOffset<T>::type build(FlatBufferBuilder& builder, const T& value)
{
    if constexpr (is_optional<T>)
    {
        if (!value.has_value())
            return 0;
{{~ for nullable_field in context.nullable_fields ~}}
{{~ if nullable_field.is_primitive ~}}
        if constexpr (std::is_same_v<T, {{ nullable_field | @cpp_type }}>)
        {
            return nullable::Createnullable_{{ nullable_field.type }}(builder, value.value());
        }

{{~ end ~}}
{{~ end ~}}
        return build<typename T::value_type>(builder, value.value());
    }
    else if constexpr (is_vector<T>)
    {
        if constexpr (std::is_fundamental_v<typename T::value_type>)
        {
            return builder.CreateVector(value);
        }
        else
        {
            auto buffer = std::vector<typename FlatBufferOffset<typename T::value_type>::type>();
            for (auto& x : value)
            {
                buffer.push_back(build<typename T::value_type>(builder, x));
            }
            return builder.CreateVector(buffer);
        }
    }
    else if constexpr (std::is_enum_v<T>)
    {
        return static_cast<typename FlatBufferOffset<T>::type>(value);
    }
    else
    {
        return value;
    }
}

template <> 
Offset<String> build<std::string>(FlatBufferBuilder& builder, const std::string& value);

{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <>
Offset<{{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> build<{{ scope.namespace | array.add table.name | array.join '::' }}>(FlatBufferBuilder& builder, const {{ scope.namespace | array.add table.name | array.join '::' }}& value);
{{~ end ~}}
{{~ end ~}}

{{~ for array_field in context.array_fields ~}}
{{~ if array_field.array_element.is_primitive ~}}
{{~ if array_field.array_element.is_nullable ~}}
Offset<Vector<Offset<nullable::nullable_{{ array_field.array_element.type }}>>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value);
{{~ else ~}}
Offset<Vector<{{ array_field.array_element | @cpp_type }}>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value);
{{~ end ~}}
{{~ else ~}}
Offset<Vector<Offset<{{ array_field.array_element.fixed_namespace | array.add 'raw' | array.add array_field.array_element.type | array.join '::' }}>>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value);
{{~ end ~}}
{{~ end ~}}

template <typename T> inline static
std::vector<T> unpack(const flatbuffers::Vector<typename FlatBufferOffset<T>::type> *value)
{
    auto result = std::vector<T>();
    for (int i = 0; i < value->size(); i++)
    {
        if constexpr (is_optional<T>)
        {
            if (value->Get(i) == nullptr)
            {
                result.push_back(std::nullopt);
            }
            else if constexpr (std::is_fundamental_v<typename T::value_type>)
            {
                result.push_back(value->Get(i)->value());
            }
            else
            {
                result.push_back(*value->Get(i));
            }
        }
        else
        {
            if constexpr (std::is_fundamental_v<T>)
            {
                result.push_back(value->Get(i));
            }
            else
            {
                result.push_back(*value->Get(i));
            }
        }
    }
    return result;
}

}

{{~ for scope in context.scopes ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}
{{~ end ~}}
{{~ for enum in scope.enums ~}}
enum class {{ enum.name }} : {{ to_field(enum.type) | @cpp_type }}
{
{{~ for value in enum.values ~}}
    {{ value }} = {{ enum.scope.namespace | array.add 'raw' | array.add enum.name | array.add enum.name + '_' + value | array.join '::' }},
{{~ end ~}}
};
{{~ end ~}}
{{~ if (scope.enums | array.size) > 0 ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
{{ for n in scope.namespace }}namespace {{ n }} { {{ end }}

enum class FlatBufferProtocolType
{
{{~ for table in scope.tables ~}}
    {{ table.name }},
{{~ end ~}}
};

{{~ for table in scope.tables ~}}
class {{ table.name }}
{
public:
    static inline {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.join '::' }} FlatBufferProtocolType = {{ scope.namespace | array.add 'FlatBufferProtocolType' | array.add table.name | array.join '::' }};

{{~ if (table.fields | array.size) > 0 ~}}
public:
{{~ for field in table.fields ~}}
    {{ field | @cpp_type }} {{ field.name }}{{ field | @cpp_default_value }};
{{~ end ~}}
{{~ end ~}}

public:
    {{ table.name }}() = default;

    {{ table.name }}(const {{ table.name }}& x)
{{~ if (table.fields | array.size) > 0 ~}}
        : {{ for field in table.fields }}{{ field.name }}(x.{{ field.name }}){{ if !for.last }}, {{end }}{{ end }}
{{~ end ~}}
    { }

{{~ if (table.fields | array.size) > 0 ~}}
    {{ table.name }}({{ for field in table.fields }}{{ field | @cpp_decorate_const_ref }} {{ field.name }}{{ if !for.last }}, {{end }}{{ end }})
        : {{ for field in table.fields }}{{ field.name }}({{ field.name }}){{ if !for.last }}, {{ end }}{{ end }}
    { }
{{~ end ~}}

    {{ table.name }}(const {{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}& raw)
{{~ if (table.fields | array.size) > 0~}}
        : {{ for field in table.fields }}{{ field.name }}({{ cpp_create_field('raw', field) }}){{ if !for.last }}, {{ end }}{{ end }}
{{~ end ~}}
    { }

public:
    std::vector<uint8_t> Serialize() const
    {
        auto builder = flatbuffers::FlatBufferBuilder();
        builder.Finish(build<{{ table.scope.namespace | array.add table.name | array.join '::' }}>(builder, *this));
        auto size = builder.GetSize();
        auto result = std::vector<uint8_t>(size);
        std::memcpy(result.data(), builder.GetBufferPointer(), size);
        return result;
    }

    static {{ table.name }} Deserialize(const uint8_t* bytes)
    {
        auto raw = {{ scope.namespace | array.add 'raw' | array.add 'Get' + table.name | array.join '::' }}(bytes);
        return {{ table.name }}(*raw);
    }
};
{{~ end ~}}
{{ for n in scope.namespace }}} {{ end }}
{{~ end ~}}

namespace flatbuffers {

template <> 
Offset<String> build<std::string>(FlatBufferBuilder& builder, const std::string& value)
{
    return builder.CreateString(value);
}

{{~ for scope in context.scopes ~}}
{{~ for table in scope.tables ~}}
template <>
Offset<{{ scope.namespace | array.add 'raw' | array.add table.name | array.join '::' }}> build<{{ scope.namespace | array.add table.name | array.join '::' }}>(FlatBufferBuilder& builder, const {{ scope.namespace | array.add table.name | array.join '::' }}& value)
{
    return {{ scope.namespace | array.add 'raw' | array.add 'Create' + table.name | array.join '::' }}(builder{{ if (table.fields | array.size) > 0 }},
{{~ for field in table.fields ~}}
            {{ cpp_create_offset(field, 'value.' + field.name) }}{{ if !for.last }},
{{ end }}{{~ end ~}}{{ end }});
}
{{~ end ~}}
{{~ end ~}}

{{~ for array_field in context.array_fields ~}}
{{~ if array_field.array_element.is_primitive ~}}
{{~ if array_field.array_element.is_nullable ~}}
Offset<Vector<Offset<nullable::nullable_{{ array_field.array_element.type }}>>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value)
{{~ else ~}}
Offset<Vector<{{ array_field.array_element | @cpp_type }}>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value)
{{~ end ~}}
{
{{~ if array_field.array_element.is_nullable ~}}
    auto result = std::vector<Offset<nullable::nullable_{{ array_field.array_element.type }}>>();
    for (auto& x : value)
    {
        if (x.has_value())
            result.push_back(flatbuffers::build<{{ array_field.array_element | @cpp_type }}>(builder, x));
        else
            result.push_back(0);
    }
    return builder.CreateVector(result);
{{~ else ~}}
    return builder.CreateVector(value);
{{~ end ~}}
}
{{~ else ~}}
Offset<Vector<Offset<{{ array_field.array_element.fixed_namespace | array.add 'raw' | array.add array_field.array_element.type | array.join '::' }}>>> build(FlatBufferBuilder& builder, const {{ array_field | @cpp_type }}& value)
{
    auto result = std::vector<Offset<{{ array_field.array_element.fixed_namespace | array.add 'raw' | array.add array_field.array_element.type | array.join '::' }}>>();
    for (auto& x : value)
    {
        result.push_back(flatbuffers::build<{{ array_field.array_element | @cpp_type }}>(builder, x));
    }
    return builder.CreateVector(result);
}
{{~ end ~}}
{{~ end ~}}

}

#endif