{{~
func cs_type_from_str(type)
    $result = ''
    case type
        when "string"
            $result = "string"
        when "byte"
            $result = "sbyte"
        when "ubyte"
            $result = "byte"
        when "array"
            $result = "List<" + (field.array_element | @cs_type) + ">"
        else
            $result = type
    end

    ret $result
end

func cs_type(field)
    $result = @cs_type_from_str(field.type)
    if field.refer_namespace
        $result = (field.refer_namespace | array.add $result | array.each @cs_mapped_kwd | array.join '.')
    else if field.is_custom_class
        $result = (field.scope.namespace | array.add $result | array.each @cs_mapped_kwd | array.join '.')
    end

    if field.is_nullable
        if field.type == 'string'
        
        else if field.is_custom_class
        
        else
            $result = $result + '?'
        end
    end

    ret $result
end

func create_offset(field, fix_name=false)
    $result = ''
    $name = field.name
    if !fix_name
        $name = $name | upper_camel
    end
    if field.type == 'string'
        $result = 'builder.CreateString(' + $name + ')'
    else if field.is_custom_class
        $result = $name + '.Build(builder)'
    else if field.type == 'array'
        $clone = field.array_element | clone_field
        $clone.name = 'x'
        $result = (field.scope.namespace | array.add 'raw' | array.add field.table.name | array.add 'Create' + $name + 'Vector' | array.join '.') + '(builder, ' + $name + '.Select(x => ' + create_offset($clone, true) + ').ToArray())'
    else if field.is_enum
        $result = '(' + (field.fixed_namespace | array.add 'raw' | array.add field.type | array.each @cs_mapped_kwd | array.join '.') +')' + $name
    else
        $result = $name
    end

    if field.is_bound_nullable
        $nullable_name = (['nullable'] | array.concat field.fixed_namespace | array.add field.type | array.join '_' | string.downcase)
        $clone = field | @clone_field
        $clone.name = $name + '.Value'
        $clone.is_nullable = false
        $result = $nullable_name + '.Create' + $nullable_name + '(builder, ' + create_offset($clone, true) + ')'
    end

    if field.is_nullable
        $result = $name + ' != null ? ' + $result + ' : default'
    end
    ret $result
end

func cs_access_nullable_value(value, field)
    if field.is_custom_class
        ret value + '.Value'
    else if field.type == 'string'
        ret value
    else if field.is_nullable
        ret value + '.Value'
    else if field.is_enum
        ret '(' + (field.fixed_namespace | array.add field.type | array.each @cs_mapped_kwd | array.join '.') + ')' + value
    else if field.is_primitive
        ret value
    else
        ret value + '()'
    end
end

func cs_create_field(raw_name, field)
    $result = ''
    $flatbuffer_offset = raw_name
    if field.name
        $flatbuffer_offset = $flatbuffer_offset + '.' + (field.name | upper_camel)
    end
    $flatbuffer_value = cs_access_nullable_value($flatbuffer_offset, field)

    if field.is_bound_nullable
        $casting_type = '(' + (field.fixed_namespace | array.add (field | @cs_type) | array.each @cs_mapped_kwd | array.join '.') + ')'
        $flatbuffer_value = $casting_type + $flatbuffer_value + '.Value'
    end

    if field.is_custom_class
        $value = 'new ' + field.type + '(' + $flatbuffer_value + ')'
    else if field.type == 'string'
        $value = $flatbuffer_value
    else if field.type == 'array'
        $value = 'Enumerable.Range(0, raw.' + (field.name | upper_camel) + 'Length).Select(i => raw.' + (field.name | upper_camel) + '(i)).Select(x => ' + cs_create_field('x', field.array_element) + ').ToList()'
    else if field.is_enum
        $value = $flatbuffer_value
    else
        $value = $flatbuffer_value
    end

    if field.is_nullable && field.type != 'string'
        $result = $flatbuffer_offset + ' != null ? ' + $value + ' : null'
    else
        $result = $value
    end

    ret $result
end

func cs_default_value(field)
    $result = ''
    if field.init
        $result = field.init
    else if field.is_nullable
        $result = 'null'
    else
        case field.type
        when "string"
            $result = "string.Empty"
        when "byte", "ubyte", "short", "ushort", "int", "uint"
            $result = "0"
        when "long", "ulong"
            $result = "0L"
        when "float"
            $result = "0.0f"
        when "double"
            $result = "0.0"
        when "bool"
            $result = "false"
        when "array"
            $result = "new " + cs_type(field) + '()'
        end
    end

    if $result != ''
        $result = ' = ' + $result + ';'
    end

    ret $result
end
~}}
using Google.FlatBuffers;
using nullable;

namespace Google.FlatBuffers
{
    public interface IFlatBufferEx
    {
        int ProtocolType { get; }
        byte[] Serialize();
    }
}

{{~ for scope in context.scopes ~}}
namespace {{ scope.namespace | array.each @cs_mapped_kwd | array.join '.' }}
{
    public enum FlatBufferProtocolType
    { 
{{~ for table in scope.tables ~}}
        {{ table.name }}{{ if !for.last }},{{ end }}
{{~ end ~}}
    }
}
{{~ end ~}}

{{~ for scope in context.scopes ~}}
namespace {{ scope.namespace | array.each @cs_mapped_kwd | array.join '.' }}
{
{{~ for enum in scope.enums ~}}
    public enum {{ enum.name }}
    {
{{~ for value in enum.values ~}}
        {{ value }},
{{~ end ~}}
    }
{{~ end ~}}

{{~ for table in scope.tables ~}}
    public class {{ table.name }} : IFlatBufferEx
    {
        public int ProtocolType => (int)FlatBufferProtocolType.{{ table.name }};
{{~ for field in table.fields ~}}
        public {{ field | @cs_type }} {{ field.name | upper_camel }} { get; set; }{{ field | @cs_default_value }}
{{~ end ~}}

        public {{ table.name }}()
        { }

        public {{ table.name }}({{ scope.namespace | array.add 'raw' | array.add table.name | array.each @cs_mapped_kwd | array.join '.' }} raw)
        {
{{~ for field in table.fields ~}}
            {{ field.name | upper_camel }} = {{ cs_create_field('raw', field) }};
{{~ end ~}}
        }

        public {{ table.name }}(byte[] bytes) : this({{ scope.namespace | array.add 'raw' | array.add table.name | array.each @cs_mapped_kwd | array.join '.' }}.GetRootAs{{ table.name }}(new ByteBuffer(bytes)))
        { }

        public Offset<{{ scope.namespace | array.add 'raw' | array.add table.name | array.each @cs_mapped_kwd | array.join '.' }}> Build(FlatBufferBuilder builder)
        {
{{~ if (table.fields | array.size) > 0 ~}}
            return {{ scope.namespace | array.add 'raw' | array.add table.name | array.each @cs_mapped_kwd | array.join '.' }}.Create{{ table.name }}(builder,
{{~ for field in table.fields ~}}
                {{ field | @create_offset }}{{ if !for.last }},
{{~ end ~}}
{{~ end ~}});
{{~ else ~}}
            {{ table.scope.namespace | array.add 'raw' | array.each @cs_mapped_kwd | array.add table.name | array.add ('Start' + table.name) | array.join '.'}}(builder);
            return {{ table.scope.namespace | array.add 'raw' | array.each @cs_mapped_kwd | array.add table.name | array.add ('End' + table.name) | array.join '.'}}(builder);
{{~ end ~}}
        }

        public byte[] Serialize()
        {
            var builder = new FlatBufferBuilder(1);
            var offset = Build(builder);
            builder.Finish(offset.Value);
            return builder.SizedByteArray();
        }

        public static {{ table.name }} Deserialize(byte[] bytes)
        {
            return new {{ table.name }}(bytes);
        }
    }
{{~ end ~}}

    public static class FlatBufferProtocolRouter
    {
        public static Type GetProtocolType(FlatBufferProtocolType protocolType)
        {
            return protocolType switch
            {
{{~ for table in scope.tables ~}}
                FlatBufferProtocolType.{{ table.name }} => typeof({{ scope.namespace | array.add table.name | array.each @cs_mapped_kwd | array.join '.'}}),
{{~ end ~}}
                _ => throw new ArgumentException(),
            };
        }
    }
}
{{~ end ~}}